classdef SpectralOracle < Oracle
% An abstact spectral oracle class for unconstrained spectral composite optimization.
% 
% Note:
%
%   This oracle is specialized for solving nonconvex composite optimization problems in which $f_s = f_{1,s} + f_{2,s}^{\cal V}
%   \circ \sigma$ and $f_n = f_{n}^{\cal V} \circ \sigma$ for absolutely symmetric functions $f_{2,s}^{\cal V}$ and
%   $f_{n}^{\cal V}$. Here, $\sigma()$ denotes operator that maps matrices to some form of type of spectral vector, e.g. a
%   singular value vector.
%   
%   Unlike the the usual ``Oracle`` object, this one has an additional method named ``spectral_eval()`` that takes two arguments, 
%   ``{X, x}``, and updates $(f_s, f_n)$ with ``X`` and $(f_{2,s}^{\cal V}, f_n^{\cal V})$ with ``x`` separately. This can be
%   helpful when the spectral vector $\sigma(X)$ has already been computed. If ``x=[]``, the expected behavior is that ``x`` is
%   computed from $\sigma()$.
%
%
% See Also:
%
%   Kong, W., & Monteiro, R. D. (2020). Accelerated Inexact Composite Gradient Methods for Nonconvex Spectral Optimization
%   Problems. *arXiv preprint arXiv:2007.11772*.
%
% Attributes:
%
%   spectral_grad_f2_s (function handle): A zero argument function that, when evaluated, outputs $\nabla f_{2,s}^{\cal V}(x)$.
%     Defaults to ``@() zeros(size(x))``.
%
%   spectral_prox_f_n (function handle): A one argument function that, when evaluated at $\lambda$, outputs $${\rm prox}_{\lambda
%     f_{n}^{\cal V}}(x) := {\rm argmin}_u \left\{\lambda f_n^{\cal V}(u) + \frac{1}{2}\|u-x\|^2\right\}.$$ Defaults to
%     ``@(lam) x``.
%
%   f1_s (function handle): A zero argument function that, when evaluated, outputs $f_{1,s}(X)$. Defaults to ``@() 0``.
%
%   f2_s (function handle): A zero argument function that, when evaluated, outputs $f_{2,s}(X)$. Defaults to ``@() 0``.
%
%   grad_f1_s (function handle): A zero argument function that, when evaluated, outputs $\nabla f_{1,s}(X)$. Defaults to 
%     ``@() zeros(size(X))``.
%
%   grad_f2_s (function handle): A zero argument function that, when evaluated, outputs $\nabla f_{2,s}(X)$. Defaults to 
%     ``@() zeros(size(X))``.
%
%   decomp_fn (function handle): A one argument function that, when evaluated at $X$, outputs three arguments ``{P, D, Q}`` where
%     ``D`` is a diagonal matrix, ``P`` and ``Q`` are orthogonal matrices, and $X=PDQ^*$. Defaults to ``@(X) svd(X, 'econ')``.
  
  %% CONSTRUCTORS
  methods
    function obj = SpectralOracle(varargin)
    % The constructor for the SpectralOracle class. It has three ways to initialize: 
    %   
    %   - ``Oracle()`` creates an oracle that represents the zero function, i.e. $f_s = f_n \equiv 0$.
    %   - ``Oracle(f_s, f_n, grad_f_s, prox_f_n)`` creates an Oracle object with the properties ``f_s``, ``f_n``, ``grad_f_s``,
    %     and ``prox_f_n`` filled by the corresponding inputs.
    %   - ``Oracle(spectral_eval_fn)`` creates an Oracle object which, when spectrally evaluated at a pair ``{X, x}``, updates the
    %     properties related to ``f_s``, ``f_n``, ``grad_f_s``, and ``prox_f_n`` as follows:
    %
    %     .. code-block:: matlab
    %       
    %       % Update the suboracles
    %       f_s = spectral_eval_fn(X, x).f_s;
    %       f_n = spectral_eval_fn(X, x).f_n;
    %       grad_f_s = spectral_eval_fn(X, x).grad_f_s;
    %       prox_f_n = spectral_eval_fn(X, x).prox_f_n;
    %       spectral_grad_f2_s = spectral_eval_fn(X, x).spectral_grad_f2_s;
    %       spectral_prox_f_n = spectral_eval_fn(X, x).spectral_grad_f2_s;
    %
    %     Similar updates are made for ``f_s_at_prox_f_n``, ``f_n_at_prox_f_n``, and ``grad_f_s_at_prox_f_n``, if these are 
    %     generated by the underlying evaluator.
    %
      if (nargin == 0)  
        obj.final_eval = @(X, x) struct('f_s', @() 0, 'f_n', @() 0, 'grad_f_s', @() zeros(size(X)), 'prox_f_n', @(lam) X, ...
                                        'spectral_grad_f2_s', @() zeros(size(x)), 'spectral_prox_f_n', @(lam) x, 'f1_s', @() 0, ...
                                        'f2_s', @() 0, 'grad_f1_s', @() zeros(size(x)), 'grad_f2_s', @() zeros(size(x)), ...
                                        'decomp_fn', @(Z) svd(Z, 'econ'));
      elseif (nargin == 4) 
        obj.final_eval = @(X, x) struct('f_s', @() feval(varargin{1}, X), 'f_n', @() feval(varargin{2}, X), ...
                                        'grad_f_s', @() feval(varargin{3}, X), 'prox_f_n', @(lam) feval(varargin{4}, X, lam), ...
                                        'spectral_grad_f2_s', @() zeros(size(x)), 'spectral_prox_f_n', @(lam) zeros(size(x)), ...
                                        'f1_s', @() 0, 'f2_s', @() 0, 'grad_f1_s', @() zeros(size(x)), ...
                                        'grad_f2_s', @() zeros(size(x)), 'decomp_fn', @(Z) svd(Z, 'econ'));
      elseif (nargin == 1) 
        obj.final_eval = varargin{1};
      else
        error(['Incorrect number of arguments: ', num2str(nargin)]);
      end
    end
    
  end
  
  %% ORACLES
  properties (SetAccess = public)
    spectral_grad_f2_s
    spectral_prox_f_n
    f1_s
    f2_s
    grad_f1_s
    grad_f2_s
    decomp_fn
  end
  properties (SetAccess = private, Hidden = true)
    orig_f2_s
    orig_f_n
  end
  
  %% METHODS
  methods
    function obj = eval(obj, X)
    % An alias for ``obj.spectral_eval(X, [])``.
      obj.eval_point = X;
      obj.spectral_eval(X, []);
    end
    function obj = spectral_eval(obj, X, x)
    % Evaluates the spectral oracle at a pair ``{X, x}`` and updates all of the relevant properties at this pair. 
      Fn = obj.final_eval(X, x);
      obj.f_s = @() Fn.f_s();
      obj.f_n = @() Fn.f_n();
      obj.grad_f_s = @() Fn.grad_f_s();
      obj.prox_f_n = @(lam) Fn.prox_f_n(lam);
      obj.spectral_grad_f2_s = @() Fn.spectral_grad_f2_s();
      obj.spectral_prox_f_n = @(lam) Fn.spectral_prox_f_n(lam);
      obj.f1_s = @() Fn.f1_s();
      obj.f2_s = @() Fn.f2_s();
      obj.grad_f1_s = @() Fn.grad_f1_s();
      obj.grad_f2_s = @() Fn.grad_f2_s();
      if isfield(Fn, 'orig_f2_s')
        obj.orig_f2_s = Fn.orig_f2_s;
      end
      if isfield(Fn, 'orig_f_n')
        obj.orig_f_n = Fn.orig_f_n;
      end
    end
    
    function scale(obj, alpha)
    % Modified the suboracles by multiplying by a positive constant ``alpha``. That is, the properties ``f_s``, ``f_n``,
    % ``grad_f_s``, and ``prox_f_n`` are updated as follows:
    %
    % .. code-block:: matlab
    %
    %   f_s(x) = alpha * f_s(x);
    %   f_n(x) = alpha * f_n(x); 
    %   grad_f_s(x) = alpha * grad_f_s(x);
    %   prox_f_n(x, lambda) = prox_f_n(x, alpha * lambda);
    %
      final_eval_cpy = obj.final_eval;
      function scaled_Fn = scaled_eval(x)
        Fn = final_eval_cpy(x, []);
        scaled_Fn = Fn;
        scaled_Fn.f_s = @(x) alpha * Fn.f_s();
        scaled_Fn.grad_f_s = @(x) alpha * Fn.grad_f_s();
        scaled_Fn.f_n = @(x) alpha * Fn.f_n();
        scaled_Fn.prox_f_n = @(lam) Fn.prox_f_n(lam * alpha);
        % Account for hidden oracles.
        if isfield(Fn, 'f_s_at_prox_f_n')
          scaled_Fn.f_s_at_prox_f_n = @(lam) alpha * Fn.f_s_at_prox_f_n(lam * alpha);
        end
        if isfield(Fn, 'f_n_at_prox_f_n')
          scaled_Fn.f_n_at_prox_f_n = @(lam) alpha * Fn.f_n_at_prox_f_n(lam * alpha);
        end
        if isfield(Fn, 'grad_f_s_at_prox_f_n')
          scaled_Fn.grad_f_s_at_prox_f_n = @(lam) alpha * Fn.grad_f_s_at_prox_f_n(lam * alpha);
        end
      end
      obj.final_eval = @(X, x_dummy) scaled_eval(X);
    end
    
    function add_prox(obj, x_hat)
    % Modified the suboracles by adding a prox term at a point ``x_hat``. That is, the properties ``f_s``, ``f_n``, ``grad_f_s``,
    % and 
    % ``prox_f_n`` are updated as follows:
    %
    % .. code-block:: matlab
    %
    %   f_s(x) = f_s(x) + (1 / 2) * norm_fn(x - x_hat) ^ 2;
    %   grad_f_s(x) = grad_f_s(x) + (x - x_hat);
    %
      final_eval_cpy = obj.final_eval;
      function add_prox_Fn = add_prox_eval(x)
        Fn = final_eval_cpy(x, []);
        add_prox_Fn = Fn;
        add_prox_Fn.f_s = @() Fn.f_s() + (1/2) * obj.norm_fn(x - x_hat)^2;
        add_prox_Fn.grad_f_s = @() Fn.grad_f_s() + (x - x_hat);
      end
      obj.final_eval = @(X, x_dummy) add_prox_eval(X);
    end
    
    function vector_linear_proxify(obj, alpha, x_hat)
    % Denoting $\alpha = {\rm alpha}$ and $\hat{x} = {\rm x\_hat}$, calling this method changes the underlying function of the
    % oracle as follows:
    %
    % .. math::
    %
    %   f_{s}(x) & \gets\alpha f_{2,s}^{\cal V}(x)-\left\langle 
    %   x,\hat{x}\right\rangle +\frac{1}{2}\|x\|^{2},\\
    %   f_{n}(x) & \gets\alpha f_{n}^{\cal V}(x).
    %
    % This method is primarily used to convert the oracle from one that acts on a matrix space to one that acts on a vector space.
    % It also makes sure that the ``eval()`` method is properly adjusted to take in vector inputs rather than matrix inputs.
    %
      final_eval_cpy = obj.final_eval;      
      function combined_struct = vlp_eval(x)
        dim_n = length(x);
        dummy_dg_x = spdiags(x, 0, dim_n, dim_n);
        base_struct = final_eval_cpy(dummy_dg_x, x);
        combined_struct = base_struct;
        combined_struct.orig_f2_s = @() base_struct.f2_s();
        combined_struct.orig_f_n = @() base_struct.f_n();
        combined_struct.f_s = @() alpha * base_struct.f2_s() - obj.prod_fn(x, x_hat) + obj.norm_fn(x) ^ 2 / 2;
        combined_struct.f_n = @() alpha * base_struct.f_n();
        combined_struct.grad_f_s = @() alpha * base_struct.spectral_grad_f2_s() + (x - x_hat);
        combined_struct.prox_f_n = @(lam) base_struct.spectral_prox_f_n(lam * alpha);
      end
      % Curry the eval_proxy_fn operator.
      obj.final_eval = @(x, x_dummy) vlp_eval(x);
    end
    
    function redistribute_curvature(obj, alpha)
      % Denoting $\alpha = {\rm alpha}$, calling this method changes the underlying function of the oracle as follows:
      %
      % .. math::
      %
      %   f_{1,s}(X) & \gets f_{1,s}(X)-\frac{\alpha}{2}\|X\|_{F}^{2},\\
      %   f_{2,s}(X) & \gets f_{2,s}(X)+\frac{\alpha}{2}\|X\|_{F}^{2},\\
      %   f_{2,s}^{{\cal V}}(x) & \gets 
      %     f_{2,s}^{{\cal V}}(x)+\frac{\alpha}{2}\|x\|^{2}.
      %
      final_eval_cpy = obj.final_eval; 
      function combined_struct = redist_eval(X, x)
        base_struct = final_eval_cpy(X, x);
        combined_struct = base_struct;
        combined_struct.f1_s = @() base_struct.f1_s() - alpha * obj.norm_fn(X) ^ 2 / 2;
        combined_struct.f2_s = @() base_struct.f2_s() + alpha * obj.norm_fn(X) ^ 2 / 2;
        combined_struct.grad_f1_s = @() base_struct.grad_f1_s() - alpha * X;
        combined_struct.grad_f2_s = @() base_struct.grad_f2_s() + alpha * X;
        combined_struct.spectral_grad_f2_s = @() base_struct.spectral_grad_f2_s() + alpha * x;
      end
      obj.final_eval = @(X, x) redist_eval(X, x);
    end
    
    function [f_s, f_n, grad_f_s, prox_f_n] = decompose(obj)
    % A zero argument method that, when evaluated, returns variants of the properties ``f_s``, ``f_n``, ``grad_f_s``, and
    % ``prox_f_n``, where an additional argument ``x`` is added to the beginning of the of the list of function inputs. For
    % example, the value ``f = f_s(x)``, computed from the output function, is equivalent to:
    %
    % .. code-block:: matlab
    %
    %   my_oracle.eval(x);
    %   f = my_oracle.f_s();
    %
    % where my_oracle refers to the oracle object that is calling 
    % ``decompose()``.
    %
      f_s = @(x) feval(subsref(obj.final_eval(x, []), struct('type','.','subs','f_s')));
      f_n = @(x) feval(subsref(obj.final_eval(x, []), struct('type','.','subs','f_n')));
      grad_f_s = @(x) feval(subsref(obj.final_eval(x, []), struct('type','.','subs','grad_f_s')));
      % Multi-input functions
      prox_f_n = @(x, lam) feval(subsref(obj.final_eval(x, []), struct('type','.','subs','prox_f_n')), lam);
    end
    
  end
  
end
