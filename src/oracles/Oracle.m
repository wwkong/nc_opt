classdef Oracle < matlab.mixin.Copyable & dynamicprops
  % An abstact oracle class for unconstrained composite optimization.
  % 
  % Attributes:
  %
  %   f_s (function handle): A zero argument function that, when evaluated, 
  %     outputs $f_s(x)$. Defaults to ``@() 0``.
  %
  %   grad_f_s (function handle): A zero argument function that, when 
  %     evaluated, outputs $\nabla f_s(x)$. Defaults to ``@() zeros(size(x))``.
  %
  %   f_n (function handle): A zero argument function that, when evaluated, 
  %     outputs $f_n(x)$. Defaults to ``@() 0``.
  %
  %   prox_f_n (function handle): A one argument function that, when evaluated 
  %     at $\lambda$, outputs $${\rm prox}_{\lambda f_n}(x) := 
  %     {\rm argmin}_u \left\{\lambda f_n(u) + \frac{1}{2}\|u-x\|^2\right\}.$$
  %     Defaults to ``@(lam) x``.
  %
  %   f_s_at_prox_f_n (function handle): A one argument function that, when 
  %     evaluated at $\lambda$, returns the value of $f_s$ at the point
  %     given by the function ``prox_f_n`` at $\lambda$. This is generally
  %     used to speed up certain algorithms (see :mod:`src.solves.ACG`).
  %     Defaults to ``None``.
  %
  %   prod_fn (function handle): A two argument function that, when evaluated
  %     at $\{a, b\}$, outputs the inner product $\langle a,b \rangle$. 
  %     Defaults to the Euclidean inner product, i.e., 
  %     ``@(a,b) sum(dot(a, b))``.
  %
  %   norm_fn (function handle): A one function that, when evaluated at a 
  %     point $a$, outputs $\|a\|$. Defaults to the Frobenius norm, i.e., 
  %     ``norm(a, 'fro')``.
  %  

  % -----------------------------------------------------------------------
  %% CONSTRUCTORS
  % -----------------------------------------------------------------------
  
  methods
    
    function obj = Oracle(varargin)
      % The constructor for the Oracle class. It has three ways to 
      % initialize: 
      %   
      %   - ``Oracle`` creates an oracle that represents the zero function, 
      %     i.e., $f_s = f_n \equiv 0$.
      %   - ``Oracle(f_s, f_n, grad_f_s, prox_f_n)`` creates an 
      %     Oracle object with the properties ``f_s``, ``f_n``, ``grad_f_s``,
      %     and ``prox_f_n`` filled by the corresponding inputs.
      %   - ``Oracle(eval_fn)`` creates an Oracle object which, when evaluated
      %     at a point $x$, updates the properties ``f_s``, ``f_n``,
      %     ``grad_f_s``, and ``prox_f_n`` as follows:
      %
      %     .. code-block:: matlab
      %
      %       f_s = eval_fn(x).f_s;
      %       f_n = eval_fn(x).f_n;
      %       grad_f_s = eval_fn(x).grad_f_s;
      %       prox_f_n = eval_fn(x).prox_f_n;
      %
      %     Similar updates are made for ``f_s_at_prox_f_n``, 
      %     ``f_n_at_prox_f_n``, and ``grad_f_s_at_prox_f_n``, if these are 
      %     generated by ``eval_fn()``.
      if (nargin == 0) % default constructor with dummy values
        obj.final_eval = @(~) struct(...
        'f_s', @(x) 0, ...
        'f_n', @(x) 0, ...
        'grad_f_s', @(x) zeros(size(x)), ...
        'prox_f_n', @(x, lam) x);
      elseif (nargin == 4) % basic oracle constructor
        obj.final_eval = @(~) struct(...
        'f_s', @(x) feval(varargin{1}, x), ...
        'f_n', @(x) feval(varargin{2}, x), ...
        'grad_f_s', @(x) feval(varargin{3}, x), ...
        'prox_f_n', @(x, lam) feval(varargin{4}, x, lam));
      elseif (nargin == 1) % evaluator type constructor
        obj.final_eval = varargin{1};
      else
        error(['Incorrect number of arguments: ', num2str(nargin)]);
      end
      % Default pre and post-processors (identity operators).
      obj.pre.lam = @(val) val;
      obj.post.f_s = @(val, x) val;
      obj.post.f_n = @(val, x) val;
      obj.post.grad_f_s = @(val, x) val;
      obj.post.prox_f_n = @(val, x, lam) val;
    end
    
  end
  
  % -----------------------------------------------------------------------
  %% ORACLES
  % -----------------------------------------------------------------------
  
  % Visible attributes
  properties (Access = public)
    f_s
    f_n
    grad_f_s
    prox_f_n
    eval_point
    prod_fn = @(a,b) sum(dot(a, b))
    norm_fn = @(a) norm(a, 'fro') 
  end
  
  % Hidden attributes
  properties (Access = public, Hidden = true)
    f_s_at_prox_f_n
    f_n_at_prox_f_n
    grad_f_s_at_prox_f_n
  end
  
  % Function oracles (respresenting the evaluators).
  properties (SetAccess = protected, Hidden = true)
    % A generator of a structure containing function handles that
    % correspond to the pure functions (f_s, f_n, grad_f_s, prox_f_n), of the 
    % oracle. Its input is an ``eval_point``.
    final_eval
    % Struct that containts functions that pre-process the inputs of pure functions.
    pre;
    % Struct that contains functions that post-process the values generated by the evaluation of pure functions.
    post;
  end
  
  % -----------------------------------------------------------------------
  %% METHODS
  % -----------------------------------------------------------------------
  
  % Primary methods.
  methods
    
    function obj = eval(obj, x)
      % Evaluates the oracle at a point ``x`` and updates the properties 
      % ``f_s``, ``f_n``, ``grad_f_s``, and ``prox_f_n`` to be at this point.
      obj.eval_point = x;
      Fn = obj.final_eval(x);
      obj.f_s = @() obj.post.f_s(Fn.f_s(x), x);
      obj.f_n = @() obj.post.f_n(Fn.f_n(x), x);
      obj.grad_f_s = @() obj.post.grad_f_s(Fn.grad_f_s(x), x);
      obj.prox_f_n = @(lam) obj.post.prox_f_n(Fn.prox_f_n(x, obj.pre.lam(lam)), x, obj.pre.lam(lam));
    end
    
    function add_smooth_oracle(obj, other_obj)
      % Modified the suboracles by adding the smooth suboracles of an input oracle to the smooth suboracles of the current 
      % oracle (assumes the input oracle can be easily decomposed). That is, the properties ``f_s``, ``f_n``, ``grad_f_s``, and 
      % ``prox_f_n`` are updated as follows:
      %
      % .. code-block:: matlab
      %
      %   f_s(x) = f_s(x) + input_oracle.f_s(x);
      %   grad_f_s(x) = grad_f_s(x) + input_oracle.grad_f_s(x);
      %
      [other_f_s, ~, other_grad_f_s, ~] = decompose(other_obj);
      f_s_cpy = obj.post.f_s;
      grad_f_s_cpy = obj.post.grad_f_s;
      obj.post.f_s = @(v, x) f_s_cpy(v, x) + other_f_s(x);
      obj.post.grad_f_s = @(v, x) grad_f_s_cpy(v, x) + other_grad_f_s(x);
    end
    
    function scale(obj, alpha)
      % Modifies the suboracles by multiplying by a positive constant 
      % ``alpha``. That is, the properties ``f_s``, ``f_n``, ``grad_f_s``, 
      % and ``prox_f_n`` are updated as follows:
      %
      % .. code-block:: matlab
      %
      %   f_s(x) = alpha * f_s(x);
      %   f_n(x) = alpha * f_n(x); 
      %   grad_f_s(x) = alpha * grad_f_s(x);
      %   prox_f_n(x, lambda) = prox_f_n(x, alpha * lambda);
      %
      lam_cpy = obj.pre.lam;
      f_s_cpy = obj.post.f_s;
      grad_f_s_cpy = obj.post.grad_f_s;
      f_n_cpy = obj.post.f_n;
      obj.pre.lam = @(lam) alpha * lam_cpy(lam);
      obj.post.f_s = @(v, x) alpha * f_s_cpy(v, x);
      obj.post.grad_f_s = @(v, x) alpha * grad_f_s_cpy(v, x);
      obj.post.f_n = @(v, x) alpha * f_n_cpy(v, x);
    end
    
    function add_prox(obj, x_hat)
      % Modified the suboracles by adding a prox term at a point ``x_hat``. 
      % That is, the properties ``f_s``, ``f_n``, ``grad_f_s``, and 
      % ``prox_f_n`` are updated as follows:
      %
      % .. code-block:: matlab
      %
      %   f_s(x) = f_s(x) + (1 / 2) * norm_fn(x - x_hat) ^ 2;
      %   grad_f_s(x) = grad_f_s(x) + (x - x_hat);
      %
      
      
%       f_s_cpy = obj.post.f_s;
%       grad_f_s_cpy = obj.post.grad_f_s;
%       disp(obj.post.grad_f_s);
%       obj.post.f_s = @(v, x) f_s_cpy(v, x) + (1/2) * obj.norm_fn(x - x_hat)^2;
%       obj.post.grad_f_s = @(v, x) grad_f_s_cpy(v, x) +  (x - x_hat);
      disp(obj.post.grad_f_s);

      final_eval_cpy = obj.final_eval;
      function add_prox_Fn = add_prox_eval(x)
        Fn = final_eval_cpy(x);
        add_prox_Fn = Fn;
        add_prox_Fn.f_s = @(x) Fn.f_s(x) + (1/2) * obj.norm_fn(x - x_hat)^2;
        add_prox_Fn.grad_f_s = @(x) Fn.grad_f_s(x) + (x - x_hat);
      end
      obj.final_eval = @add_prox_eval;
      
    end
    
    function proxify(obj, alpha, x_hat)
      % Modify the suboracles by multiplying by a positive constant 
      % ``alpha`` and then adding a prox term at a point ``x_hat``. 
      % That is, the properties ``f_s``, ``f_n``, ``grad_f_s``, and 
      % ``prox_f_n`` are updated as follows:
      %
      % .. code-block:: matlab
      %
      %   f_s(x) = alpha * f_s(x) + (1 / 2) * norm_fn(x - x_hat) ^ 2;
      %   f_n(x) = alpha * f_n(x);
      %   grad_f_s(x) = alpha * grad_f_s(x) + (x - x_hat);
      %   prox_f_n(x, lambda) = prox_f_n(x, alpha * lambda);
      %
      obj.scale(alpha)
      obj.add_prox(x_hat)
    end
    
    function [f_s, f_n, grad_f_s, prox_f_n] = decompose(obj)
      % A zero argument method that, when evaluated, returns variants of the 
      % properties ``f_s``, ``f_n``, ``grad_f_s``, and ``prox_f_n``, where 
      % an additional argument ``x`` is added to the beginning of the 
      % of the list of function inputs. For example, the value ``f = f_s(x)``,
      % computed from the output function, is equivalent to:
      %
      % .. code-block:: matlab
      %
      %   my_oracle.eval(x);
      %   f = my_oracle.f_s();
      %
      % where my_oracle refers to the oracle object that is calling 
      % ``decompose()``.
      %
      f_s = @(x) feval(subsref(obj.final_eval(x), ...
        struct('type','.','subs','f_s')), x);
      f_n = @(x) feval(subsref(obj.final_eval(x), ...
        struct('type','.','subs','f_n')), x);
      grad_f_s = @(x) feval(subsref(obj.final_eval(x), ...
        struct('type','.','subs','grad_f_s')), x);
      % Multi-input functions
      prox_f_n = @(x, lam) feval(subsref(obj.final_eval(x), ...
        struct('type','.','subs','prox_f_n')), x, lam);
    end
    
  end
  
end

% Utility functions
function cond_addProp(obj, str)
  if ~isprop(obj, str)
    addprop(obj, str)
  end
end