classdef Oracle < matlab.mixin.Copyable & dynamicprops
% An abstact oracle class for unconstrained composite optimization.
% 
% Attributes:
%
%   f_s (function handle): A zero argument function that, when evaluated, outputs $f_s(x)$. Defaults to ``@() 0``.
%
%   grad_f_s (function handle): A zero argument function that, when evaluated, outputs $\nabla f_s(x)$. Defaults to
%   ``@() zeros(size(x))``.
%
%   f_n (function handle): A zero argument function that, when evaluated, outputs $f_n(x)$. Defaults to ``@() 0``.
%
%   prox_f_n (function handle): A one argument function that, when evaluated at $\lambda$, outputs $${\rm prox}_{\lambda f_n}(x)
%     := {\rm argmin}_u \left\{\lambda f_n(u) + \frac{1}{2}\|u-x\|^2\right\}.$$ Defaults to ``@(lam) x``.
%
%   f_s_at_prox_f_n (function handle): A one argument function that, when evaluated at $\lambda$, returns the value of $f_s$ at
%     the point given by the function ``prox_f_n`` at $\lambda$. This is generally used to speed up certain algorithms (see
%     src/solvers/ACG.m). Defaults to ``None``.
%
%   prod_fn (function handle): A two argument function that, when evaluated at $\{a, b\}$, outputs the inner product $\langle a,b
%     \rangle$. Defaults to the Euclidean inner product, i.e. ``@(a,b) sum(dot(a, b))``.
%
%   norm_fn (function handle): A one function that, when evaluated at a point $a$, outputs $\|a\|$. Defaults to the Frobenius
%     norm, i.e. ``norm(a, 'fro')``.

  %% CONSTRUCTORS
  methods
    function obj = Oracle(varargin)
    % The constructor for the Oracle class. It has three ways to initialize: 
    %   
    %   - ``Oracle()`` creates an oracle that represents the zero function, i.e. $f_s = f_n \equiv 0$.
    %   - ``Oracle(f_s, f_n, grad_f_s, prox_f_n)`` creates an Oracle object with the properties ``f_s``, ``f_n``, ``grad_f_s``,
    %     and ``prox_f_n`` filled by the corresponding inputs.
    %   - ``Oracle(eval_fn)`` creates an Oracle object which, when evaluated at a point $x$, updates the properties ``f_s``,
    %     ``f_n``, ``grad_f_s``, and ``prox_f_n`` as follows:
    %
    %     .. code-block:: matlab
    %
    %       f_s = eval_fn(x).f_s;
    %       f_n = eval_fn(x).f_n;
    %       grad_f_s = eval_fn(x).grad_f_s;
    %       prox_f_n = eval_fn(x).prox_f_n;
    %
    %     Similar updates are made for ``f_s_at_prox_f_n``, ``f_n_at_prox_f_n``, and ``grad_f_s_at_prox_f_n``, if these are 
    %     generated by ``eval_fn()``.
      if (nargin == 0) 
        obj.final_eval = @(x) struct('f_s', @() 0, 'f_n', @(x) 0, 'grad_f_s', @() zeros(size(x)), 'prox_f_n', @(lam) x);
      elseif (nargin == 4) 
        obj.final_eval = @(x) struct('f_s', @() feval(varargin{1}, x), 'f_n', @() feval(varargin{2}, x), ...
                                     'grad_f_s', @() feval(varargin{3}, x), 'prox_f_n', @(lam) feval(varargin{4}, x, lam));
      elseif (nargin == 1) 
        obj.final_eval = varargin{1};
      else
        error(['Incorrect number of arguments: ', num2str(nargin)]);
      end
    end
    
  end
  
  %% ORACLES
  properties (Access = public)
    f_s
    f_n
    grad_f_s
    prox_f_n
    eval_point
    prod_fn = @(a,b) sum(dot(a, b))
    norm_fn = @(a) norm(a, 'fro') 
  end
  properties (Access = public, Hidden = true)
    f_s_at_prox_f_n
    f_n_at_prox_f_n
    grad_f_s_at_prox_f_n
  end
  properties (SetAccess = protected, Hidden = true)
    % A generator of a structure containing function handles that correspond to the pure functions (f_s, f_n, grad_f_s, prox_f_n)
    % of the oracle. Its input is an ``eval_point``.
    final_eval
  end
  
  %% METHODS
  methods
    function obj = eval(obj, x)
     % Evaluates the oracle at a point ``x`` and updates the properties ``f_s``, ``f_n``, ``grad_f_s``, and ``prox_f_n`` to be at
     % this point.
      obj.eval_point = x;
      Fn = obj.final_eval(x);
      obj.f_s = @() Fn.f_s();
      obj.f_n = @() Fn.f_n();
      obj.grad_f_s = @() Fn.grad_f_s();
      obj.prox_f_n = @(lam) Fn.prox_f_n(lam);
    end
    
    function add_smooth_oracle(obj, other_obj)
    % Modified the suboracles by adding the smooth suboracles of an input oracle to the smooth suboracles of the current oracle. 
    % That is, the properties ``f_s``, ``f_n``, ``grad_f_s``, and ``prox_f_n`` are updated as follows:
    %
    % .. code-block:: matlab
    %
    %   f_s(x) = f_s(x) + input_oracle.f_s(x);
    %   grad_f_s(x) = grad_f_s(x) + input_oracle.grad_f_s(x);
      %
      final_eval_cpy = obj.final_eval;
      function smooth_add_Fn = smooth_add_eval(x)
        Fn = final_eval_cpy(x);
        other_Fn = other_obj.final_eval(x);
        smooth_add_Fn = Fn;
        smooth_add_Fn.f_s = @() Fn.f_s() + other_Fn.f_s();
        smooth_add_Fn.grad_f_s = @() Fn.grad_f_s() + other_Fn.grad_f_s();
        % Account for hidden oracles.
        if isfield(smooth_add_Fn, 'f_s_at_prox_f_n')
          smooth_add_Fn.f_s_at_prox_f_n = @(lam) Fn.f_s_at_prox_f_n(lam) + other_Fn.f_s_at_prox_f_n(lam);
        end
        if isfield(smooth_add_Fn, 'grad_f_s_at_prox_f_n')
          smooth_add_Fn.grad_f_s_at_prox_f_n = @(lam) Fn.grad_f_s_at_prox_f_n(lam) + other_Fn.grad_f_s_at_prox_f_n(lam);
        end
      end
      obj.final_eval = @smooth_add_eval;
    end
    
    function scale(obj, alpha)
    % Modified the suboracles by multiplying by a positive constant ``alpha``. That is, the properties ``f_s``, ``f_n``,
    % ``grad_f_s``, and ``prox_f_n`` are updated as follows:
    %
    % .. code-block:: matlab
    %
    %   f_s(x) = alpha * f_s(x);
    %   f_n(x) = alpha * f_n(x); 
    %   grad_f_s(x) = alpha * grad_f_s(x);
    %   prox_f_n(x, lambda) = prox_f_n(x, alpha * lambda);
    %
      final_eval_cpy = obj.final_eval;
      function scaled_Fn = scaled_eval(x)
        Fn = final_eval_cpy(x);
        scaled_Fn = Fn;
        scaled_Fn.f_s = @() alpha * Fn.f_s();
        scaled_Fn.grad_f_s = @() alpha * Fn.grad_f_s();
        scaled_Fn.f_n = @() alpha * Fn.f_n();
        scaled_Fn.prox_f_n = @(lam) Fn.prox_f_n(lam * alpha);
        % Account for hidden oracles.
        if isfield(Fn, 'f_s_at_prox_f_n')
          scaled_Fn.f_s_at_prox_f_n = @(lam) alpha * Fn.f_s_at_prox_f_n(lam * alpha);
        end
        if isfield(Fn, 'f_n_at_prox_f_n')
          scaled_Fn.f_n_at_prox_f_n = @(lam) alpha * Fn.f_n_at_prox_f_n(lam * alpha);
        end
        if isfield(Fn, 'grad_f_s_at_prox_f_n')
          scaled_Fn.grad_f_s_at_prox_f_n = @(lam) alpha * Fn.grad_f_s_at_prox_f_n(lam * alpha);
        end
      end
      obj.final_eval = @scaled_eval;
    end
    
    function add_prox(obj, x_hat)
    % Modified the suboracles by adding a prox term at a point ``x_hat``. That is, the properties ``f_s``, ``f_n``, ``grad_f_s``,
    % and 
    % ``prox_f_n`` are updated as follows:
    %
    % .. code-block:: matlab
    %
    %   f_s(x) = f_s(x) + (1 / 2) * norm_fn(x - x_hat) ^ 2;
    %   grad_f_s(x) = grad_f_s(x) + (x - x_hat);
    %
      final_eval_cpy = obj.final_eval;
      function add_prox_Fn = add_prox_eval(x)
        Fn = final_eval_cpy(x);
        add_prox_Fn = Fn;
        add_prox_Fn.f_s = @() Fn.f_s() + (1/2) * obj.norm_fn(x - x_hat)^2;
        add_prox_Fn.grad_f_s = @() Fn.grad_f_s() + (x - x_hat);
      end
      obj.final_eval = @add_prox_eval;
    end
    
    function proxify(obj, alpha, x_hat)
    % Modify the suboracles by multiplying by a positive constant ``alpha`` and then adding a prox term at a point ``x_hat``. 
    % That is, the properties ``f_s``, ``f_n``, ``grad_f_s``, and ``prox_f_n`` are updated as follows:
    %
    % .. code-block:: matlab
    %
    %   f_s(x) = alpha * f_s(x) + (1 / 2) * norm_fn(x - x_hat) ^ 2;
    %   f_n(x) = alpha * f_n(x);
    %   grad_f_s(x) = alpha * grad_f_s(x) + (x - x_hat);
    %   prox_f_n(x, lambda) = prox_f_n(x, alpha * lambda);
    %
      obj.scale(alpha)
      obj.add_prox(x_hat)
    end
    
    function [f_s, f_n, grad_f_s, prox_f_n] = decompose(obj)
    % A zero argument method that, when evaluated, returns variants of the properties ``f_s``, ``f_n``, ``grad_f_s``, and
    % ``prox_f_n``, where an additional argument ``x`` is added to the beginning of the of the list of function inputs. For
    % example, the value ``f = f_s(x)``, computed from the output function, is equivalent to:
    %
    % .. code-block:: matlab
    %
    %   my_oracle.eval(x);
    %   f = my_oracle.f_s();
    %
    % where my_oracle refers to the oracle object that is calling 
    % ``decompose()``.
    %
      f_s = @(x) feval(subsref(obj.final_eval(x), struct('type','.','subs','f_s')));
      f_n = @(x) feval(subsref(obj.final_eval(x), struct('type','.','subs','f_n')));
      grad_f_s = @(x) feval(subsref(obj.final_eval(x), struct('type','.','subs','grad_f_s')));
      % Multi-input functions
      prox_f_n = @(x, lam) feval(subsref(obj.final_eval(x), struct('type','.','subs','prox_f_n')), lam);
    end
    
  end
  
end

% Utility functions
function cond_addProp(obj, str)
  if ~isprop(obj, str)
    addprop(obj, str)
  end
end
