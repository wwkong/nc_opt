Overview of the API
===================

This section presents a high level overview of the NC-OPT MATLAB interface. All sections following this one present a comprehensive description of the key classes, solvers, and frameworks.

Creating a Model
----------------
NC-OPT allows you to model problems of the following form:

.. math::

  \text{minimize} \quad & f_s(x) + f_n(x) \\
  \text{subject to} \quad  & g(x) \in S.

Models are generated by using constructors for the ``CompModel`` or ``ConstrCompModel`` classes, each containing properties that specify its various components such as solvers, oracles, and tolerances. By default, the empty constructor sets:

.. math::

  f_n \equiv 0, \quad g \equiv 0, \quad S = \{0\}.

It also is assumed that the user configures the model so that the set :math:`S` and the functions :math:`f_s`, :math:`f_n`, and :math:`g` satisfy the following minimal assumptions:

* The set :math:`S` is either empty or nonempty and convex.
* The function :math:`f_s` is continuously differentiable and its gradient is :math:`L`-Lipschitz continuous.
* The function :math:`f_n` is proper, closed, and convex.
* The function :math:`g` is either empty, linear, or (cone) convex.
* Either :math:`\inf_u [f_s(u) + f_n(u)] > -\infty` or the domain of :math:`f_n` is compact.

After constructing the model, one or more of the following components need to be specified, depending on the type of model created.

Initial Point and :math:`L`
^^^^^^^^^^^^^^^^^^^^^^^^^^^
For ``CompModel`` or ``ConstrCompModel`` objects, the user needs to provide: (a) an initial point :math:`x_0` in the domain of ``f_n``; and (b) the Lipschitz constant :math:`L` of the gradient of :math:`f_s`. These can be specified by setting the ``x0`` and ``L`` properties of the models.  

Oracle
^^^^^^
For ``CompModel`` or ``ConstrCompModel`` objects, the user needs to provide a subset of the functions above or a first-order oracle, represented by an ``Oracle`` object, to the model. The first-order oracle has a method ``eval()`` which, when evaluated at point, returns information about the objective function at that point.

Solver
^^^^^^
For ``CompModel`` or ``ConstrCompModel`` objects, the user needs to provide a composite optimization solver to the model. This solver takes an ``Oracle`` object and a ``struct`` object of hyperparameters as input, and outputs a solution associated the problem underlying the oracle.

Framework
^^^^^^^^^
For ``ConstrCompModel`` objects, the user needs to provide a constrained optimization framework to the model. This framework takes a ``ConstrCompModel`` object as input, and outputs a solution associated the problem underlying the model.

Solving a Model
---------------
When a model has been fully constructed, it can solved by invoking the ``optimize()`` method of the underlying model object. More specifically, this method applies either the underlying ``solver`` or ``framework`` to produce an approximate stationary point of the associated optimization problem. For unconstrained problems, this point is a pair :math:`(x, v)` satisfying

.. math::

  \begin{gather}
    v \in \nabla f_s(x) + \partial f_n(x), \\
    x \in {\rm dom}\, f_n, \quad \|v\| \leq \rho, 
  \end{gather}

for a given tolerance :math:`\rho \in {\mathbb R}_{++}`. For constrained problems, this point is a quadruple :math:`(x, y, v, w)` satisfying

.. math::

  \begin{gather}
      v \in \nabla f_s(x) + \partial f_n(x) + \nabla g(x) y, \\
      \quad x \in {\rm dom}\, f_n, \quad y \in S^{*} \quad \|v\| \leq \rho, \quad \|w\| \leq \eta, \\
      \left\langle g(x) + w, y\right\rangle = 0, \quad g(x) + w \in S,
  \end{gather}

for a given tolerance pair :math:`(\rho, \eta) \in {\mathbb R}_{++}^2`. Messages about the model's configuration and final status of the model will be output to the MATLAB command line.

A Simple Example
----------------

Below is a simple example for solving the unconstrained univariate optimization problem

.. math::

  \underset{x}{\text{minimize}} \quad \frac{1}{2} (x - 1)^2 + 1.

.. code-block:: matlab
    :linenos:

    % Create the Model object and specify the solver.
    cvx_qp = CompModel;
    cvx_qp.solver = @AIPP;

    % Define the function and its gradient.
    cvx_qp.f_s = @(x) (1 / 2) * (x - 1) ^ 2;
    cvx_qp.grad_f_s = @(x) x - 1;

    % Set the Lipschitz constant of the gradient and the starting point x0.
    cvx_qp.L = 10;
    cvx_qp.x0 = 10;

    % Solve the problem.
    cvx_qp.optimize;

The complete code for this example can be found in ``examples/unconstrained/basic_convex_qp.m``.
